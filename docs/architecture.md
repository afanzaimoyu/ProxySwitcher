# ProxySwitcher 架构说明

本文档从整体角度说明 ProxySwitcher 的系统架构、模块职责以及设计取舍。

---

## 一、整体架构概览

ProxySwitcher 是一个 **常驻后台运行的 Windows 工具**，核心由以下部分组成：

- 网络环境采集模块
- 环境判定与状态机模块
- 系统代理应用模块
- 系统服务与生命周期管理模块

其运行模型是一个**周期性闭环**，而非事件驱动或一次性脚本。

---

## 二、核心模块划分

### 1. 网络采集模块（network_win.go）

职责：

- 调用 Win32 API `GetAdaptersAddresses`
- 获取当前系统所有网络适配器的快照
- 提取以下关键信息：
    - 接口类型（Wi-Fi / Ethernet）
    - IP 地址
    - 是否启用

设计原因：

- 不依赖网卡名称字符串
- 避免中英文系统差异
- 避免用户手动重命名网卡导致误判

---

### 2. 决策与状态机模块（manager.go）

职责：

- 根据网络快照判断当前“环境”
- 维护代理目标状态
- 实现防抖与稳定性控制

这是整个项目的**核心逻辑层**。

该模块不直接操作系统，仅输出“是否应开启代理”的结论。

---

### 3. 系统代理应用模块（registry_win.go）

职责：

- 修改 Windows 系统代理相关注册表
- 控制代理开启 / 关闭
- 写入代理地址

设计原则：

- 只操作 WinInet 代理相关键值
- 不修改路由、不影响 VPN
- 每次修改后主动刷新系统状态

---

### 4. 生命周期与服务管理（main.go / service_win.go）

职责：

- 前台调试模式
- Windows Service 安装 / 卸载
- 信号监听与优雅退出
- 程序退出时恢复系统环境

---

## 三、运行流程总结

1. 程序启动
2. 进入定时心跳循环（默认 5 秒）
3. 获取网络快照
4. 判断当前环境
5. 状态机稳定后决定是否切换代理
6. 如需切换，写注册表并广播刷新
7. 等待下一次循环

---

## 四、设计取舍说明

### 为什么不用脚本？

- 脚本难以处理防抖与中间态
- 无法优雅处理服务生命周期
- 稳定性不可控

### 为什么不用事件监听？

- Windows 网络事件噪声极大
- 实际仍需状态机过滤
- 轮询 + 防抖更可预测

---

## 五、设计目标

ProxySwitcher 刻意追求：

- 行为确定
- 状态可推理
- 出问题易排查

而非“看起来很智能”。

这是一个系统工具应有的姿态。




```markdown
┌──────────────┐
│ 定时心跳 5s  │
└──────┬───────┘
↓
┌─────────────────────┐
│ 获取网卡硬件快照     │
│ GetAdaptersAddresses│
└──────┬──────────────┘
↓
┌─────────────────────┐
│ 判断物理网卡类型     │
│ Wi-Fi / 有线         │
└──────┬──────────────┘
↓
┌─────────────────────┐
│ 环境加权判断         │
│ 外网 Wi-Fi > 内网    │
└──────┬──────────────┘
↓
┌─────────────────────┐
│ 状态机防抖判断       │
│ 连续一致才切换       │
└──────┬──────────────┘
↓
┌─────────────────────┐
│ 修改系统代理注册表   │
└──────┬──────────────┘
↓
┌─────────────────────┐
│ WinInet 广播刷新     │
│ 浏览器立即生效       │
└─────────────────────┘

```
